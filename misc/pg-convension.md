# 探探PostgreSQL规范

* TanTan DBA Team —— 冯若航



## 0x00背景  

> 没有规矩，不成方圆。

PostgreSQL的功能非常强大，但是要把PostgreSQL用好，需要后端、运维、DBA的协力配合。  

本文针对PostgreSQL数据库原理与特性，整理了一份开发规范，希望可以减少大家在使用PostgreSQL数据库过程中遇到的困惑。  你好我也好，大家都好。  



## 0x01 命名规范

> 无名，万物之始，有名，万物之母。

==【强制】== **通用命名规则**

* 本规则适用于所有对象名，包括：库名、表名、表名、列名、函数名、视图名、序列号名、别名等。
* 对象名务必只使用小写字母，下划线，数字，但首字母必须为小写字母，常规表禁止以`_`打头。
* 对象名长度不超过63个字符，命名统一采用`snake_case`。
* 禁止出现美元符号，禁止使用中文，不要使用SQL保留字，不要以`pg`开头。 
* 提高用词品味，做到信达雅；不要使用拼音，不要使用生僻冷词，不要使用小众缩写。



==【强制】== **库命名规则**

* 库名最好与应用或服务保持一致，必须为具有高区分度的英文单词。
* 命名必须以`<biz>-`开头，其中`<biz>`为业务名称，如果是分片库必须以`-shard`结尾。
* 多个部分使用`-`连接。例如：`<biz>-chat-shard`，`<biz>-payment`等，总共不超过三段。



==【强制】== **角色命名规范**

* 数据库`su`有且仅有一个：`postgres`，用于流复制的用户命名为`replication`。
* 生产用户命名使用`<biz>-`作为前缀，具体功能作为后缀。
* 所有数据库默认有三个基础角色： `<biz>-read`，`<biz>-write`，`<biz>-usage`，分别拥有所有表的只读，只写，函数的执行权限。
* 生产用户，ETL用户，个人用户通过继承相应的基础角色获取权限。



==【强制】== **模式命名规则**

* 业务使用`<xxx>`作为模式名（`<xxx>`为统一使用的模式名），必须设置为`search_path`首位元素。
* `dba`，`monitor`，`trash`为保留模式名。
* 分片模式命名规则采用：`rel_<partition_total_num>_<partition_index>`。
* 无特殊理由不应在其他模式中创建对象。



==【推荐】== **关系命名规则**

* 关系命名以表意清晰为第一要义，不要使用含混的缩写，也不应过分冗长，遵循通用命名规则。
* 表名应当使用复数名词，与历史惯例保持一致，但应尽量避免带有不规则复数形式的单词。
* 视图以`v_`作为命名前缀，物化视图使用`mv_`作为命名前缀，临时表以`tmp_`作为命名前缀。
* 继承或分区表应当以父表表名作为前缀，并以子表特性（规则，分片范围等）作为后缀。



==【推荐】== **索引命名规则**

* 创建索引时如有条件应当指定索引名称，并与PostgreSQL默认命名规则保持一致。
* 用于主键的索引以`_pkey`结尾，唯一索引以`_key`结尾，用于`EXCLUDED`约束的索引以`_excl`结尾，普通索引以`_idx`结尾。



==【推荐】== **函数命名规则**

* 以`select`,`insert`,`delete`,`update`,`upsert`打头，表示动作类型。
* 重要参数可以通过`_by_ids`, `_by_user_ids`的后缀在函数名中体现。
* 相同功能，不同参数的函数使用相同的函数名，通过参数类型重载。



==【推荐】== **字段命名规则**

* 不得使用系统列保留字段名：`oid`, `xmin`, `xmax`,`cmin`, `cmax`, `ctid`等。
* 主键列通常命名为`id`，或以`id`作为后缀。
* 创建时间通常命名为`created_time`，修改时间通常命名为`modified_time`
* 布尔型字段建议使用`is_`，`has_`等作为前缀。
* 其余各字段名需与已有表命名惯例保持一致。



==【推荐】== **变量命名规则**

* 存储过程与函数中的变量使用命名参数，而非位置参数。
* 如果参数名与对象名出现冲突，在参数后添加`_`，例如`user_id_`。



==【推荐】== **注释规范**

* 尽量为对象提供注释（`COMMENT`），注释使用英文，言简意赅，一行为宜。
* 对象的模式或内容语义发生变更时，务必一并更新注释，与实际情况保持同步。



## 0x02 设计规范

==【强制】== **字符编码必须为UTF8**

* 禁止使用其他任何字符编码。



==【强制】== **容量规划**

- 单表记录过亿，或超过10GB的量级，可以考虑开始进行分表。
- 单表容量超过1T，单库容量超过2T。需要考虑分片。



==【强制】== **不要滥用存储过程**

* 存储过程适用于封装事务，减少并发冲突，减少网络往返，减少返回数据量，执行**少量**自定义逻辑。
* 存储过程**不适合**进行复杂计算，不适合进行平凡的类型转换与包装。



==【强制】== **存储计算分离**

* 移除数据库中**不必要**的计算密集型逻辑，例如在数据库中使用SQL进行WGS84到其他坐标系的换算。
* 例外：与数据获取、筛选密切关联的计算逻辑允许在数据库中进行，如PostGIS中的几何关系判断。



==【强制】== **主键与身份列**

* 每个表都必须有**身份列**，原则上必须有主键，最低要求为拥有**非空唯一约束**。
* 主键推荐使用`BIGINT`，不得使用长字符串。
* 频繁`UPSERT`或出现插入冲突的表建议使用自定义发号函数代替序列号，（例如SnowflakeID）。
* 建议主键使用发号器函数：采用高位时间戳+低位序列号取模的方式，不建议直接使用`BIGSERIAL`。



==【强制】== **外键与级联操作**

* 使用外键时，引用必须设置相应的动作：`SET NULL`, `SET DEFAULT`, `CASCADE`，慎用级联操作。



==【强制】== **慎用宽表**

* 字段数目超过20个的表视作宽表，宽表应当考虑进行纵向拆分，通过主键与外键做一对一关联。
* 因为MVCC机制，宽表的写放大现象比较明显，尽量减少对宽表的频繁更新。



==【强制】== **配置合适的默认值**

* 有默认值的列必须添加`DEFAULT`子句指定默认值。
* 可以在默认值中使用函数，动态生成默认值（例如主键发号器）。



==【强制】== **合理应对空值**

- 字段语义上没有零值与空值区分的，不允许空值存在，须为列配置`NOT NULL`约束。

  

==【强制】== **基本的数据完整性须通过约束保证**。

* 唯一约束须由数据库保证，任何唯一列须有唯一约束。
* `EXCLUDE`约束可以在低频更新场景下使用，保证数据完整性。



==【强制】== **注意整数溢出风险**

* 注意SQL标准不提供无符号整型，超过`INTMAX`但没超过`UINTMAX`的值需要升格存储。
* 不要存储超过`INT64MAX`的值到bigint列中。
* 整型主键列使用BIGINT。



==【强制】== **注意时区问题**

* 使用`TIMESTAMP`存储时间时，一律采用UTC，GMT时间（0时区），或采用`TIMESTAMPTZ`。



==【推荐】== **选择合理的规范化等级**

- PostgreSQL对多表JOIN有良好的支持，允许使用更高的规范化等级。
- 建议使用2NF，3NF，通过多表连接降低数据冗余。
- 建议通过新表外键关联扩充功能，而不是为主表添加字段。



==【推荐】== **使用更新的版本，充分利用高级特性**

* 新版本有无成本的性能提升，稳定性提升，有更多新功能。
* 充分利用新特性，降低设计复杂度。



==【推荐】== **选择合适的类型**

* 能使用专有类型的，不使用字符串。（数值，枚举，网络地址，货币，JSON，UUID等）
* 使用正确的数据类型，能显著提高数据存储，查询，索引，计算的效率，并提高可维护性。



==【推荐】== **使用枚举类型**

* 较稳定的，取值空间较小（十几个内）的字段应当使用枚举类型，不要使用整型与字符串表示。
* 使用枚举类型有性能、存储、可维护性上的优势。



==【推荐】== **选择合适的文本类型**

* PostgreSQL的文本类型包括`char`, `char(n)`, `varchar`,`varchar(n)`, `text`。除`char(n)`外无性能区别。
* 带有n修饰符的类型会检查字符串长度，对字符串长度有限制时应当使用`varchar(n)`。
* 避免使用`char(n)`，为了与SQL标准兼容，该类型存在不合直觉的行为表现，且并没有存储和性能优势。



==【推荐】== **选择合适的数值类型**

* 常规数值字段使用INTEGER。主键外键，或容量拿不准的数值列使用BIGINT，无特殊理由不要用SMALLINT。
* `REAL`表示4字节浮点数，`FLOAT`表示8字节浮点数，使用时注意区分。



==【推荐】== **选择合适的时区**

* 建议使用`TIMESTAMPTZ`存储时间戳，如果使用`TIMESTAMP`存储时间戳，统一使用UTC，GMT时间。



==【推荐】== **针对可演化性而设计**

* 在设计表时，应当充分考虑未来的扩展需求，可以在建表时适当添加1~3个保留字段。
* 对于多变的非关键字段可以使用JSON类型。



==【推荐】== **慎用触发器**

* 触发器会提高系统的复杂度与维护成本，不鼓励使用。



## 0x03 索引规范

==【强制】== **在线查询必须有配套索引**

- 所有在线查询必须针对其访问模式设计相应索引，除极个别小表外不允许全表扫描。
- 索引有代价，不允许创建不使用的索引。
- 注意排序查询索引有序性，



==【强制】== **禁止在大字段上建立索引**

- 被索引字段大小无法超过2KB（1/3的页容量），原则上禁止超过64个字符。
- 如有大字段索引需求，可以考虑对大字段取哈希，并建立函数索引。或使用其他类型的索引（GIN）。



==【强制】== **通过外键被引用的字段必须有索引**



==【强制】== **明确空值排序规则**

* 如在可空列上有排序需求，需要在查询与索引中明确指定`NULLS FIRST`还是`NULLS LAST`。
* 注意，`DESC`排序的默认规则是`NULLS FIRST`，即空值会出现在排序的最前面，通常这不是期望行为。
* 索引的排序条件必须与查询匹配，如：`create index on tbl (id desc nulls last);` 



==【强制】== **利用GiST索引应对近邻查询问题**

- 传统B树索引无法提供对KNN问题的良好支持，应当使用GiST索引。





==【推荐】== **利用函数索引**

* 任何可以由同一行其他字段推断得出的冗余字段，可以使用函数索引替代。
* 对于经常使用表达式作为查询条件的语句，可以使用表达式或函数索引加速查询。    
* 典型场景：建立大字段上的哈希函数索引，为需要左模糊查询的文本列建立reverse函数索引。



==【推荐】== **利用部分索引**

* 查询中查询条件固定的部分，可以使用部分索引，减小索引大小并提升查询效率。
* 查询中某待索引字段若只有有限几种取值，也可以建立几个相应的部分索引。



==【推荐】== **利用范围索引**

* 对于值与堆表的存储顺序线性相关的数据，如果通常的查询为范围查询，建议使用BRIN索引。    
* 最典型场景如仅追加写入的时序数据，BRIN索引更为高效。



==【推荐】== **关注联合索引的区分度**



## 0x04 查询规范

==【强制】== **读写分离** 

- 原则上，写请求走主库，读请求走从库，除非需要读己之写的一致性保证，且检测到显著的复制延迟。
- 所有的查询都必须设置合理的超时，在线查询合理的超时量级在10ms数量级。



==【强制】== **快慢分离**

- 生产中1毫秒以内的查询称为快查询，生产中超过1秒的查询称为慢查询。
- 慢查询必须走离线从库，必须设置相应的超时。
- 生产中的在线普通查询执行时长，原则上应当控制在1ms内，超过10ms不得上线。
- 在线查询应当配置10ms数量级或更快的超时，避免堆积造成雪崩。



==【强制】== **主动超时**

- 为所有的语句配置主动超时，超时后主动取消请求，避免雪崩。
- 周期性执行的语句，必须配置小于执行周期的超时。



==【强制】== **关注一致性/复制延迟**

- 应用必须意识到主从之间的同步延迟并妥善处理好复制延迟超出合理范围的情况：平时在0.1ms的延迟，在极端情况下可能达到十几分钟甚至小时量级。应用可以选择从主库读取，稍后再度，或报错。



==【强制】== **使用连接池**

- 请通过连接池访问数据库，连接6432端口的pgbouncer而不是5432的postgres。
- 直连数据库需向DBA报备申请，并**一定**要在应用内使用连接池。
- 请注意使用连接池与直连数据库的区别，一些功能可能无法使用（Notify/Listen）
- 请注意连接池可能存在连接污染扩散的问题，所以也不要修改连接状态污染连接池。



==【强制】== **禁止修改连接状态**

- 禁止修改连接状态，包括修改连接参数，修改搜索路径，更换角色，更换数据库。
- 万不得已变更后必须彻底销毁连接，将状态变更后的连接放回连接池会导致污染扩散。



==【强制】== **重试失败的事务**

- 查询可能因为并发争用，管理员命令等原因被杀死，应用需要意识到这一点并在必要时重试。
- 应用在数据库大量报错时可以触发断路器熔断，避免雪崩。但要区分错误的类型。



==【强制】== **掉线重连**

* 连接可能因为各种原因被中止，应用**必须**有掉线重连机制。
* 可以使用`SELECT 1`作为心跳包查询，检测连接的有消息，并定期保活。



==【强制】== **应用代码禁止执行DDL**

* 不要想着在代码里搞个大新闻。
* 个别场景TRUNCATE可以例外（真有全表DELETE的需求时）。



==【强制】== **显式指定列名**

* 任何时候都不要使用`SELECT *`，请使用具体的字段列表，不要返回用不到的字段。

* 当表结构发生变动时（例如，新值列），使用列通配符的查询很可能会发生列数不匹配的错误。



==【强制】== **禁止在线查询全表扫描**

- 例外情况：常量极小表，极低频操作，表/返回结果集很小（百条记录/百KB内）。



==【强制】== **禁止在底层查询使用否定式操作符**

- 直接在底层表上使用诸如`!=`, `<>`的条件会导致全表扫描。



==【强制】==**禁止从在线库大批量拉取**

* Master与Slave角色不允许大批量拉取数据。
* 数仓ETL程序应当从Offline从库拉取数据。



==【强制】== **禁止在事务中长时间等待**

* 开启事务后必须尽快提交或回滚，超过10分钟的IDEL IN Transaction将被强制杀死。
* 应用需要开启AutoCommit，避免BEGIN之后没有配对的ROLLBACK或COMMIT。
* 尽量使用标准库提供的事务基础设施，不到万不得已不要手动控制事务。



==【强制】== **使用游标后必须及时关闭**

* 严防资源泄露



==【强制】==  **重复查询使用准备语句**

* 重复的查询应当使用Prepared Statement，消除数据库硬解析的CPU开销。
* 准备语句是连接状态，请注意连接池对于准备语句的影响。



==【强制】== **科学计数**

* `count(*)`是统计行数的标准语法，与空值无关。
* `count(col)`统计的是`col`列中的**非空记录数**。该列中的NULL值不会被计入。
* `count(distinct col)` 对`col`列除重计数，同样忽视空值，即只统计非空不同值的个数。
* `count((col1, col2))`对多列计数，即使待计数的列全为空也会被计数，`(NULL,NULL)`有效。
* `count(distinct (col1, col2))`对多列除重计数，即使待计数列全为空也会被计数，`(NULL,NULL)`有效。



==【强制】== **注意聚合函数的空值问题**

* 空值与聚合函数：聚合函数当输入值**全部**为NULL时，返回结果为NULL。
* 但`count(col)`在全是空值时返回结果为`0`，需要注意。
* 使用`SELECT coalesce(sum(col), 0) FROM tbl;`为聚合函数配置类似的默认值



==【强制】==**谨慎处理NULL值**

- 明确区分零值与空值，空值使用`IS NULL`进行等值判断，零值使用常规的`=`运算符进行等值判断。
- 空值作为函数输入参数时应当带有类型修饰符，否则对于有重载的函数将无法识别使用何者。
- 空值与**任何值**的逻辑判断，其结果都为空值，例如`NULL=NULL`返回结果是`NULL`而不是`TRUE/FALSE`。
- 涉及空值与非空值的等值比较，请使用``IS DISTINCT FROM` `进行比较，保证比较结果非空。
- 空值与聚合函数：聚合函数当输入值**全部**为NULL时，返回结果为NULL。



==【推荐】== **选择合适的事务隔离等级**

- 默认隔离等级为**读已提交**，适合大多数简单读写事务，普通事务选择满足需求的最低隔离等级。
- 需要事务级一致性快照的写事务，请使用**可重复读**隔离等级。
- 对正确性有严格要求的写入事务请使用**可序列化**隔离等级。
- 在RR与SR隔离等级出现并发冲突时，应当视错误类型进行积极的重试。



==【推荐】== **判断结果存在性不要使用count**

* 使用`SELECT 1 FROM tbl WHERE xxx LIMIT 1`判断是否存满足条件的列，要比Count快。
* 可以使用`select exists(select * FROM app.sjqq where xxx limit 1)`将存在性结果转换为布尔值。



==【推荐】== **使用RETURNING子句**

* 如果用户需要在插入数据和，删除数据前，或者修改数据后马上拿到插入或被删除或修改后的数据，建议使用`RETURNING`子句，减少数据库交互次数。
* `RETURNING`子句中也不要使用`*`，按需显式取用列。



==【推荐】== **使用UPSERT简化逻辑**

* 当业务出现插入-失败-更新的操作序列时，考虑使用UPSERT替代。
* 使用UPSERT时需要注意序列号的消耗问题。



==【推荐】== **随机取样**

* 随机取样是有科学方法的，取ID最大最小值，随机取几个区间是个办法。



==【推荐】== **利用咨询锁应对热点并发**。

* 针对单行记录的极高频并发写入（秒杀），应当使用咨询锁对记录ID进行锁定。
* 如果能在应用层次解决高并发争用，就不要放在数据库层面进行。



==【推荐】==**慎用IN操作符**

* 使用`EXISTS`子句代替`IN`操作符。
* 使用=ANY(ARRAY[1,2,3,4])代替IN。



==【推荐】== **不建议使用右模糊搜索**

* 如果真的需要，可以使用`reverse`表达式建立函数索引。



==【推荐】== **使用数组代替临时表**

* 考虑使用数组替代临时表，例如在获取一系列ID的对应记录时。`=ANY(ARRAY[1,2,3])`要比临时表JOIN好。



## 0x04 管理规范

==【强制】== **关注备份**

* 每日全量备份，段文件持续归档



==【强制】== **关注年龄**

* 关注数据库与表的年龄，避免事物ID回卷。



==【强制】== **关注老化与膨胀**

* 关注表与索引的膨胀率，避免性能劣化。



==【强制】== **关注复制延迟**

* 监控复制延迟，使用复制槽时更必须十分留意。



==【强制】== **遵循最小权限原则**

* 嫌麻烦？出了问题锅就归你了！



==【强制】==**并发地创建与删除索引**

* 对于生产表，必须使用`CREATE INDEX CONCURRENTLY`并发创建索引。



==【强制】== **新从库数据预热**

* 使用`pg_prewarm`或逐渐接入流量。



==【强制】== **审慎地进行模式变更**

* 添加新列时必须使用不带默认值的语法，避免全表重写
* 变更类型时，必要时应当重建所有依赖该类型的函数。



==【推荐】== **切分大批量操作**

* 大批量写入操作应当切分为小批量进行，避免一次产生大量WAL。



==【推荐】== **加速数据加载**

* 关闭`autovacuum`，使用`COPY`加载数据。
* 事后建立约束与索引。
* 调大`maintenance_work_mem`，增大`wal_buffer`。